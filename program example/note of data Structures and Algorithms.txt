Identifiers, Objects, and the Assignment Statement

temperature = 98.6          # temperature指向浮点对象(类)的实例98.6, python中一切皆对象，数值型也是对象；　对象存放在内存中，标识符（变量）指向这个地址；　
original = temperature      # original和temperature一样，指向同一个对象；　
temperature = temperature + 5.0  # 先执行右边的表达式，结果为103.6,是另外一个浮点对象的实例；然后，temperature重新指向这个浮点对象的地址；　而original
                                   没有变化，仍然指向原来的地址；　

python内置的可变对象(类）：list, set, dict
python 内置的不可变对象：int,bool,float,tuple,str,frozenset; #不可变对象实例不能修改，但是同一标识符可以指向另外的实例；　

list类的实例可以存放一系列的对象实例，a list is a referential structure,as it technically store a sequence of references to its elements.即，list
中存放的是指向一系列元素的地址，
list的创建，使用［］，其中没有元素，或者［１，２，３］，其中有元素；　另外，如果a=1,b=2,[a,b]也可以创建list，相当于[1,2]; 还有一种方式lists(),就是使用构造器，
其中可加参数，或不加参数；　加参数时，接受可迭代对象；　可迭代对象有：strings,list,tuples,set ,dict;
例：　a=[1, 2, 3, 4]
     b = a                  #指向同一个列表；　
     c = list(a)            #复制一个列表；　
     则： a与b指向同一个list，而c指向内容与a/b相同的另外一个list；　
     所以： id(a) == id(b) , id(c) != id(a) ; a is b , 而 a is not c;

扩展赋值运算符在可变对象和不可变对象上的差别；　
a = 1
print id(a)     # 14408840
a += 1
print id(a)     # 14408816

b = 1
print id(b)     # 14408840
b = b+1
print id(b)     # 14408816
# 如上所示，两种方式对不可变对象的结果相同，都会改变；　

l1 = [1,2,3]
print id(l1)    #32964264
l2 = l1
print id(l2)    #32964264
l2 += [4,5]
print l1        #[1, 2, 3, 4, 5]
print l2        #[1, 2, 3, 4, 5]
print id(l1)    #32964264
print id(l2)    #32964264

l3 = [1,2,3]
print id(l3)    #33038920
l4 = l3
print id(l4)    #33038920
l4 =l4 + [4,5]
print l3        #[1, 2, 3]
print l4        #[1, 2, 3, 4, 5]
print id(l3)    #33038920
print id(l4)    #33040216
#如上所示，　+= 不会改变原来的对象，而＝会改变；　


数据结构一种组织和访问数据的方式，算法是有限时间内一步步执行的程序；
统计算法优劣的放，就是执行时间；单纯通过统计时间来决定算法的优劣，有时候不太科学，因为每个程序都要共享使用cpu，cpu的释放时间依赖于其他程序，所以，科学的统计方法是算法占用的cpu时间，即时钟周期；　


第４章　递归
递归可以代替循环，递归可以用来表示一个函数在执行的时候调用一次或多次自身，或数据结构依赖于更小的与自身相同的数据结构；
递归不只可以表述函数功能，还可以表述自然界的现象，如俄罗斯套娃等；　
当一个函数使用递归调用时，调用将被挂起，直到递归调用结束；　
递归是学习数据结构和算法的重要技术，递归示例：
4.1.1 阶乘
阶乘的数学表示：n! = n.(n-1).(n-2)...3.2.1 (n>=1)   n!=1 (n=0)
阶乘的正规化表示形式：n! = n*(n-1)!         (n>=1)   n!=1 (n=0)
阶乘的函数表示：
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)   #没有循环出现，取而代之的是嵌套的递归调用；　
4.1.2 递归绘制英尺（english ruler）：
def draw_line(tick_length, tick_label=''):
    line = '-' * tick_length
    if tick_label:
        line += ' ' + str(tick_label)
    print(line)
def draw_interval(center_length):
    if center_length > 0:
        draw_interval(center_length - 1)
        draw_line(center_length)
        draw_interval(center_length - 1)
def draw_ruler(num_inches, major_length):
    draw_line(major_length, str(0) )
    for j in range(1, 1 + num_inches):
        draw_interval(major_length - 1)
        draw_line(major_length, str(j))






