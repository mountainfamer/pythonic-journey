Identifiers, Objects, and the Assignment Statement

temperature = 98.6          # temperature指向浮点对象(类)的实例98.6, python中一切皆对象，数值型也是对象；　对象存放在内存中，标识符（变量）指向这个地址；　
original = temperature      # original和temperature一样，指向同一个对象；　
temperature = temperature + 5.0  # 先执行右边的表达式，结果为103.6,是另外一个浮点对象的实例；然后，temperature重新指向这个浮点对象的地址；　而original
                                   没有变化，仍然指向原来的地址；　

python内置的可变对象(类）：list, set, dict
python 内置的不可变对象：int,bool,float,tuple,str,frozenset; #不可变对象实例不能修改，但是同一标识符可以指向另外的实例；　

list类的实例可以存放一系列的对象实例，a list is a referential structure,as it technically store a sequence of references to its elements.即，list
中存放的是指向一系列元素的地址，
list的创建，使用［］，其中没有元素，或者［１，２，３］，其中有元素；　另外，如果a=1,b=2,[a,b]也可以创建list，相当于[1,2]; 还有一种方式lists(),就是使用构造器，
其中可加参数，或不加参数；　加参数时，接受可迭代对象；　可迭代对象有：strings,list,tuples,set ,dict;
例：　a=[1, 2, 3, 4]
     b = a                  #指向同一个列表；　
     c = list(a)            #复制一个列表；　
     则： a与b指向同一个list，而c指向内容与a/b相同的另外一个list；　
     所以： id(a) == id(b) , id(c) != id(a) ; a is b , 而 a is not c;

扩展赋值运算符在可变对象和不可变对象上的差别；　
a = 1
print id(a)     # 14408840
a += 1
print id(a)     # 14408816

b = 1
print id(b)     # 14408840
b = b+1
print id(b)     # 14408816
# 如上所示，两种方式对不可变对象的结果相同，都会改变；　

l1 = [1,2,3]
print id(l1)    #32964264
l2 = l1
print id(l2)    #32964264
l2 += [4,5]
print l1        #[1, 2, 3, 4, 5]
print l2        #[1, 2, 3, 4, 5]
print id(l1)    #32964264
print id(l2)    #32964264

l3 = [1,2,3]
print id(l3)    #33038920
l4 = l3
print id(l4)    #33038920
l4 =l4 + [4,5]
print l3        #[1, 2, 3]
print l4        #[1, 2, 3, 4, 5]
print id(l3)    #33038920
print id(l4)    #33040216
#如上所示，　+= 不会改变原来的对象，而＝会改变；　


数据结构一种组织和访问数据的方式，算法是有限时间内一步步执行的程序；
统计算法优劣的放，就是执行时间；单纯通过统计时间来决定算法的优劣，有时候不太科学，因为每个程序都要共享使用cpu，cpu的释放时间依赖于其他程序，所以，科学的统计方法是算法占用的cpu时间，即时钟周期；　
算法复杂度分为空间复杂度与时间复杂度：

第４章　递归
递归可以代替循环，递归可以用来表示一个函数在执行的时候调用一次或多次自身，或数据结构依赖于更小的与自身相同的数据结构；
递归不只可以表述函数功能，还可以表述自然界的现象，如俄罗斯套娃等；　
当一个函数使用递归调用时，调用将被挂起，直到递归调用结束；　
递归是学习数据结构和算法的重要技术，递归示例：
4.1.1 阶乘
阶乘的数学表示：n! = n.(n-1).(n-2)...3.2.1 (n>=1)   n!=1 (n=0)
阶乘的正规化表示形式：n! = n*(n-1)!         (n>=1)   n!=1 (n=0)
阶乘的函数表示：
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)   #没有循环出现，取而代之的是嵌套的递归调用；　
4.1.2 递归绘制英尺（english ruler）：
def draw_line(tick_length, tick_label=''):
    line = '-' * tick_length
    if tick_label:
        line += ' ' + str(tick_label)
    print(line)
def draw_interval(center_length):
    if center_length > 0:
        draw_interval(center_length - 1)
        draw_line(center_length)
        draw_interval(center_length - 1)
def draw_ruler(num_inches, major_length):
    draw_line(major_length, str(0) )
    for j in range(1, 1 + num_inches):
        draw_interval(major_length - 1)
        draw_line(major_length, str(j))
4.1.3 二分法查找
在一个排好序的列表中查找目标对象；　mid为查找是的中间序号，low与high分别为第一个和最后一个序号；　
查找时，设，mid = (low+high)/2
则：
如果查找对象在data[mid]，则一次就可以找到目标；　
如果被查找的目标<data[mid]，则递归或循环在列表前半节数据中找，查找的区间为low-(mid-1)；
如果被查找的目标>data[mid]，则递归或循环在列表后半节数据中找,查找的区间为(mid＋1)-high；
二分查找的常规函数表示：
def binary_serach(data, target, low, high):
"""
如果找到目标数据则返回真，data已排序列表，target为被查找数据，low与high指定要查找的区间；　
"""
    if low > high:
        return False
    else:
        mid = (low + high) / 2
        if taget == data[mid]:
           return True
        elif target < data[mid]:
            return binary_search(data, target, low, mid - 1)
        else:
            return binary_search(data, target, mid + 1, high)
4.1.4 文件系统
文件系统有一个顶层的目录，其下包含文件和其他目录，目录下又有其他的文件和目录；　
文件系统的拷贝，删除操作就需要用到递归算法；　计算所有文件和目录占（嵌套）用的磁盘空间，也会用到递归算法；
算法伪代码：
DiskUsage(path):
    Input: 	要统计占用磁盘空间的路径
    Output:　　	路径下文件或目录累计占用的磁盘空间
    total = size(path)  #路径直接占用的磁盘空间
    if path就目录 then:
        for 遍历路径目录　do:
            total = total + DiskUsage(子路径)
    return total
Python代码表示：
import os
def disk_usage(path):
    total = os.path.getsize(path)    #计算path直接占用空间；　
    if os.path.isdir(path):
        for filename in os.listdir(path):
            childpath = os.path.join(path, filename)
            total += disk_usage（childpath）    
    return total
    
4.3 递归算法性能分析
递归算法的不同使用方法，对应的发费，效率，成本差别很大；　
如：　使用递归计算Fibonacci数列：
def bad_fibonacci(n):
    """Return the nth Fibonacci number."""
    if n <=1:
        return n
    else:
        return bad_fibonacci(n-2) + bad_fibonacci(n-1)
    
def good_fibonacci(n):
   """Return pair of Fibonacci numbers, F(n) and F(n-1)."""
   if n <=1:
       return (n,0)
   else:
       (a, b) = good_fibonacci(n-1)
       return (a+b, a)
4.4 递归的优化使用
根据递归调用的次数，可以把递归分为：
线性递归：递归函数体内最多一次递归调用；good_fibonacci就是线性递归的实例；　
二次递归：当函数内包含两次递归调用时，就是二次递归；　
多次递归；　

5.基于数组的数据结构
5.2 低级数组
数组将一组有联系的变量存放在计一段连续的内存中，不同的变量都有对应的内存地址，变量的地址可以
通过数组的起始地址计算出来；其中存放的是int或characters，即 primary data,不是references；　
5.2.1 基于数组的其他数据类型
list和tuple这种指示型数据结构，可以把它的每个元素看成某个类的实例；　list中存放的是这些实例的参考；　
当对list进行切片时，结果是一个新的list对象，这个list中存放的也是实例的参考，参考对应的元素并没有变；　
primes = [2,3,5,7,11,13,17,19]
temp = primes[3:6]
temp[0] = primes[3]  	#指向相同的元素；　
temp[1] = primes[4]	#指向相同的元素；　
temp[2] = primes[5]	#指向相同的元素；　
当执行temp[2] = 15时，改变的只是temp[2]的参考，而不会对primes产生任何影响；　
浅拷贝：
对于list的＂浅＂拷贝，backup = list(primes)，产生一个新的数组，和primes一样其中存放的也是参考，
他们指向相同的元素对象；
初始化一个存放int类型元素的数组：counters = [0]*8,这８个cells均指向相同的object；
当执行了counters[2]+=1后，counters[2]指向的是另一个object；其他cells指向的还是相同object;
执行primes.extend(extras)后，primes后追加的不是object，而是references；　
5.2.2 compact Array(简洁数组)
compact Array中存放的是primary　data，不是references，它的好处是占用空间小，它不像reference　araray，
除了原始数据占用空间，references也要占用空间；　
compact array的定义: 
primes = array('i',[])  #'i'为类型代码；　
5.3 







