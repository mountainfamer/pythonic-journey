 Inheritance versus COmposition(继承对组合)

- 类继承允许你根据其他类的实现来定义一个类的实现，这种通过生成子类的复用通常被称为白箱复用(white-box reuse).术语‘白箱’是相对可视性而言：在继承方式中，父类的内部细节对子类可见。
- 对象组合是类继承之外的另一种复用选择：新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为黑箱复用(black-box reuse)，因为对象的内部细节是不可见的。对象之以‘黑箱’的形式出现。

继承和组合各有优缺点，类继承是在编译时刻静态定义的，可以直接使用；缺点是继承在编译时刻就定义了，所以无法在运行时刻改变从父类继承的实现。更糟的是，父类通常至少定义了部分子类的具体表示；因为继承对子类揭示了其父类的实现细节，所以继承通常被认为“破坏吧封装性”. 子类中的实现与它的父类有如此紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。一个可用的解决方法就是只继承抽象类，因为抽象类通常提供较少的实现。

对象组合是通过获得对其他对象的引用而在运行时刻动态定义的。 组合要求对象遵循彼此的接口约定，进而要求更仔细地定义接口，而这些接口并不妨碍你将一个对象和其他对象一起使用。这还会产生良好的结果：因为对象只能通过接口访问，所以我问并不破坏封装性；只要类型一致，运行时刻还可以用一个对象来替代另一个对象； 更进一步， 因为对象的实现是基于接口写的，所以实现上存在较少的依赖关系。

对象组合对系统设计还有另外一个作用，即优先使用对象组合，有助于保持每个类被封装，并被集中在单个任务上。扎样类和类继承层次保持较小规模，不会增长为不可控制的庞然大物。另一方面，基于对象组合的设计会有更多的对象，而有较少的类，且系统的行为将依赖于对象间的关系而不是被定义在某个类中。 

所以理想情况下，不应为获得复用而去创造新的构件，你应该能够只使用对象组合技术，尽量通过组装已有的构件就能获得你需要的功能。

Delegation(委托)

Delegation is a way of making composition as powerful for reuse as inheritance(委托是一种组合方法，它使组合具有与继承同样的复用能力), 在委托方式下，有两个对象参与处理一个请求，接受请求的对象将操作委托给它的代理者。

